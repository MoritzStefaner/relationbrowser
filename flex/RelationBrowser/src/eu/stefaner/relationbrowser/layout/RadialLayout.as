package eu.stefaner.relationbrowser.layout {	import eu.stefaner.relationbrowser.ui.Node;	import flare.query.methods.eq;	import flare.vis.data.DataList;	import flare.vis.data.NodeSprite;	import flare.vis.operator.layout.Layout;	import flash.display.DisplayObjectContainer;	/**	 * @author mo	 */	public class RadialLayout extends Layout {		public var sortBy : Array;		public function RadialLayout(sortBy : Array = null) {			this.sortBy = sortBy ? sortBy : [];			layoutType = Layout.CARTESIAN;		}		protected override function layout() : void {			autoAnchor();						var selectedNode : Node = (layoutRoot as Node);			 			var r : Number = .5 * Math.max(visualization.bounds.width, visualization.bounds.height);			visualization.data.nodes.setProperties({radius:r, origin:_anchor}, _t);			_t.$(selectedNode).radius = .001;			var innerRing : DataList = new DataList("inner");			var outerRing : DataList = new DataList("outer");						visualization.data.group("visibleNodes").visit(function(n : Node) : void {				if(n == selectedNode) {					return;				} else if(n.props.distance == 1) {					innerRing.add(n);				} else {					outerRing.add(n);				}			});						innerRing.sortBy(sortBy);			outerRing.sortBy(sortBy);						var angleInc : Number = (Math.PI * 2.0) / innerRing.length;			var counter : uint = innerRing.length; 			var n : Node;						var doZigZag : uint = 0;			if (innerRing.length > 10) {				doZigZag = 1;			}			var innerRadius : Number = 240;			var angle : Number;						for each (n in innerRing) {				_t.$(n).radius = innerRadius + doZigZag * ((counter % 2) * 2 - 1) * innerRadius / 6;				angle = angleInc * counter--;				_t.$(n).angle = angle;				n.parent.addChild(n);			}						angleInc = (Math.PI * 2.0) / outerRing.length;			counter = outerRing.length;						for each (n in outerRing) {				_t.$(n).radius = innerRadius * .5 + innerRadius * .5 * n.props.distance;				angle = angleInc * counter--;				_t.$(n).angle = angle;				// get number of connections to inner ring								var numVisibleLinks : int = 0;				n.visitNodes(function(n2 : Node):void {					numVisibleLinks++;				}, NodeSprite.ALL_LINKS, eq("props.distance", 1));								// shift positions				n.visitNodes(function(n2 : Node):void {					var a1 : Number = Math.min(_t.$(n2).angle, _t.$(n).angle);					var a2 : Number = Math.max(_t.$(n2).angle, _t.$(n).angle);					var angleDiff : Number = a2 - a1;					if (angleDiff > Math.PI) {						angleDiff -= 2 * Math.PI;					}					_t.$(n).angle += angleDiff * .75 / numVisibleLinks;				}, NodeSprite.ALL_LINKS, eq("props.distance", 1));			}						 			// depth sorting			// not working yet			var nodeList : Vector.<Node> = new Vector.<Node>();			var oldAngle : Number; 			var oldRadius : Number; 			for each (n in visualization.data.group("visibleNodes")) {				oldRadius = n.radius;				oldAngle = n.angle;				n.angle = _t.$(n).angle;				n.radius = _t.$(n).radius;				n.props.depthValue = n.y;				n.angle = oldAngle;				n.radius = oldRadius;				nodeList.push(n);			}						var cmp : Function = function(a : Node, b : Node):int {				if(a.props.depthValue > b.props.depthValue) {					return 1;				}				if(a.props.depthValue < b.props.depthValue) {					return -1;				}				return 0;			};						nodeList.sort(cmp);			var p : DisplayObjectContainer = nodeList[0].parent;			var offset:int = p.numChildren - nodeList.length;			for (var i : int = 0;i < nodeList.length; i++) {				p.setChildIndex(nodeList[i], i + offset);			}		}	}}